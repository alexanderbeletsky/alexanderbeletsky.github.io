---
layout: post
title: "Inside ASP.NET MVC: IDependencyResolver - Service locator in MVC"
date: 2011-10-13T21:55:00+03:00
comments: false
categories:
 - InsideMVC
 - MVC
 - asp.net
---

<div class='post'>
<p>All types inside ASP.NET MVC3 framework are being resolved by <code>IDependencyResolver</code>. The design goal of this interface is to provide flexibility and decrease coupling between components. <br />
</p><pre class="brush:csharp">namespace System.Web.Mvc {
    using System.Collections.Generic;

    public interface IDependencyResolver {
        object GetService(Type serviceType);
        IEnumerable&lt;object&gt; GetServices(Type serviceType);
    }
}
</pre><p>If take a look into the code you will definitely smell the <a href="http://msdn.microsoft.com/en-us/library/ff648968.aspx">Service Locator</a> pattern. Indeed, <code>IDependencyResolver</code> is pure service locator.<br />
</p><h2>DependencyResolver as IDependencyResolver holder</h2><p><code>IDependencyResolver</code> instance is being accessed through the <code>DependencyResolver</code> class. <br />
</p><pre class="brush:csharp">public class DependencyResolver {
 // Static accessors

 private static DependencyResolver _instance = new DependencyResolver();

 public static IDependencyResolver Current {
  get {
   return _instance.InnerCurrent;
  }
 }
</pre><p>It is a singleton class, current instance is being accessed through <code>Current</code> property. The default implementation is <code>DefaultDependencyResolver</code>. <br />
</p><pre class="brush:csharp">// Instance implementation (for testing purposes)

private IDependencyResolver _current = new DefaultDependencyResolver();

</pre><p>Even if the comment says (for testing purposes) that class is used in real code. Let's take a look on that.<br />
</p><pre class="brush:csharp">private class DefaultDependencyResolver : IDependencyResolver {
 [SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1031:DoNotCatchGeneralExceptionTypes&quot;, Justification = &quot;This method might throw exceptions whose type we cannot strongly link against; namely, ActivationException from common service locator&quot;)]
 public object GetService(Type serviceType) {
  try {
   return Activator.CreateInstance(serviceType);
  }
  catch {
   return null;
  }
 }

 public IEnumerable&lt;object&gt; GetServices(Type serviceType) {
  return Enumerable.Empty&lt;object&gt;();
 }
}
</pre><p>As you might see, it is extremely simple. It just tries to resolve the type by <code>Activator</code> class. If the type could be resolved it just returns it's instance, otherwise just return null. The <code>GetServices</code> method just returns empty enumerable. <br />
</p><h2>Substituting default DependencyResolver</h2><p>As I said above, the main design goal of <code>DependencyResolver</code> is to provide flexibility. By flexibility I mean just easy way to substitute any type with own implementation. Say you want to change the <code>ControllerFactory</code> or <code>ModelBinder</code> or what ever you like. Everything is possible just by overriding <code>IDependencyResolver</code>.<br />
</p><p>I've seen one common misconception about MVC3, that it is contains IoC container inside it. It is not true, but it expose the interface which really much suites interfaces of famous IoC containers. To do not have a strict rules and force developers to use one type of IoC, ASP.NET MVC developers created a facility by which you can integrate yours IoC of choice. Let's have a look how to do that. <br />
</p><p><code>DependencyResolver</code> contains the number of setters to substitute the instance.<br />
</p><pre class="brush:csharp">public static void SetResolver(IDependencyResolver resolver) {
 _instance.InnerSetResolver(resolver);
}

public static void SetResolver(object commonServiceLocator) {
 _instance.InnerSetResolver(commonServiceLocator);
}

[SuppressMessage(&quot;Microsoft.Design&quot;, &quot;CA1006:DoNotNestGenericTypesInMemberSignatures&quot;, Justification = &quot;This is an appropriate nesting of generic types.&quot;)]
public static void SetResolver(Func&lt;Type, object&gt; getService, Func&lt;Type, IEnumerable&lt;object&gt;&gt; getServices) {
 _instance.InnerSetResolver(getService, getServices);
}
</pre><p>As example of implementation here my very dummy dependency resolver.<br />
</p><pre class="brush:csharp">namespace MvcForDebug2.Infrastructure {
    public class DummyDependencyResolver : IDependencyResolver {
        public object GetService(Type serviceType) {
            if (serviceType.Equals(typeof(IControllerFactory))) {
                return new DummyControllerFactory();
            }

            return null;
        }

        public IEnumerable&lt;object&gt; GetServices(Type serviceType) {
            return null;
        }
    }
}
</pre><p>Finally, in global.asx.cs you need to set it up.<br />
</p><pre class="brush:csharp">protected void Application_Start()
{
 AreaRegistration.RegisterAllAreas();

 RegisterGlobalFilters(GlobalFilters.Filters);
 RegisterRoutes(RouteTable.Routes);

 DependencyResolver.SetResolver(new DummyDependencyResolver());
 //ControllerBuilder.Current.SetControllerFactory(new DummyControllerFactory());
}
</pre><h2>Conclusions</h2><p><code>IDependencyResolver</code> is a powerful feature of ASP.NET MVC3. It is used to create all internal MVC types, so by overriding it you can override default behavior of many framework aspects. Typically you should not have any complex code in <code>GetService</code> and <code>GetServices</code> methods, but instead just delegation of call to IoC container.<br />
</p></div>
