---
layout: post
title: "Baby steps to Backbone.js: Model Validation"
date: 2012-11-08T09:42:00+02:00
comments: false
categories:
 - JavaScript
 - Backbone.js
 - BabyStepsBackbone
---

<div class='post'>
    <p>        Let's go back for a moment for <a href="http://www.beletsky.net/2012/10/baby-steps-to-backbonejs-starting-up.html">previous</a> post where we started to bootstrap some basic Backbone.js application. It's very simple now, just gathering all data and posting those data to server.<br />
    </p>    <p>        Any reliable system is almost impossible without validation. If some field is required or must conform to some particular rule, it should be validated as soon as possible and validation information should be displayed to user. User then applies corrections and re-submit data.<br />
    </p>    <p>        In case of `Feedback` model, we are interested that user always input her email and feedback message. Backbone.js provides very straight forward for models validation. If model requires validation, it should implement <a href="http://backbonejs.org/#Model-validate">validate</a> method.<br />
    </p>    <p>        So, let's extend our model with validate method.<br />
    </p>    <pre class="brush: js">var Feedback = Backbone.Model.extend({
    url: '/feedback',

    defaults: {
        'email': '',
        'website': '',
        'feedback': ''
    },

    validate: function (attrs) {
        if (!attrs.email) {
            return 'Please fill email field.';
        }
        if (!attrs.feedback) {
            return 'Please fill feedback field.';
        }
    }
});
    </pre>    <p>        As you can see, in case of email or feedback is missing, we just simply return string with error message.<br />
    </p>    <p>        To better understand what's going on, let's look on some piece of the code from Backbone.js framework. Namely, to `_validate` method of `Backbone.Model`, which is actually responsible for validation.<br />
    </p>    <pre class="brush: js">_validate: function(attrs, options) {
    if (options.silent || !this.validate) return true;
    attrs = _.extend({}, this.attributes, attrs);
    var error = this.validate(attrs, options);
    if (!error) return true;
    if (options && options.error) {
       options.error(this, error, options);
    } else {
        this.trigger('error', this, error, options);
    }
    return false;
}
</pre>    <p>        You can see, if `validate` returns either undefined or null or false, `_validate` just returns true - meaning the model is valid. Otherwise, it would check if `options.error` function initialized and call it, if not model event `error` is triggered.<br />
    </p>    <p>        During the model saving, we typically provide both success and error callbacks. It means, that error callback will be called, if model does not pass validation requirements. Inside the callback, we might decided what to do with errors. Right now, let's just do alert.<br />
    </p>    <pre class="brush: js">var options = {
    success: function () {
        alert('Thanks for the feedback!');
    },
    error: function (model, error) {
        alert(error);
    }
};

var feedback = {
    email: this.$('#email').val(),
    website:  this.$('#website').val(),
    feedback: this.$('#feedback').val()
};

this.model.save(feedback, options);
    </pre>    <p>        Notice that `error` callback receiving model itself as first argument and error object (one returned from `validate` method) as second argument. Let's try this code: leave email and feedback fields empty and press submit button.<br />
    </p>    <a href="https://lh3.googleusercontent.com/-BtV9yCmh3T8/UJtgc5Nk4CI/AAAAAAAALnQ/d671woxZwrE/s621/image-1.png"><br />
        <img src="https://lh3.googleusercontent.com/-BtV9yCmh3T8/UJtgc5Nk4CI/AAAAAAAALnQ/d671woxZwrE/s621/image-1.png"/><br />
    </a><br />
    <p>        There are several drawback of such implementation, though. First of all, `alert` windows are awful, second if user corrects email, next time she presses the submit button next alert with another message appears. This is terrible UX, so let's fix it.<br />
    </p>    <p>        So, we should basically do 2 things: aggregate all errors during validation and apply some nice styles to errors.<br />
    </p>    <p>        Instead of returning simple strings, we'll return an array of objects, containing name of failed and field and message.<br />
    </p>    <pre class="brush: js">validate: function (attrs) {
    var errors = [];

    if (!attrs.email) {
        errors.push({name: 'email', message: 'Please fill email field.'});
    }
    if (!attrs.feedback) {
        errors.push({name: 'feedback', message: 'Please fill feedback field.'});
    }

    return errors.length > 0 ? errors : false;
}
</pre>    <p>        Change the `save` method options, to show errors if any error appeared and hide errors if save was successful. <br />
    </p>    <pre class="brush: js">var me = this;
var options = {
    success: function () {
        me.hideErrors();
    },
    error: function (model, errors) {
        me.showErrors(errors);
    }
};
</pre>    <p>        And implement 2 simple methods:<br />
    </p>    <pre class="brush: js">showErrors: function(errors) {
    _.each(errors, function (error) {
        var controlGroup = this.$('.' + error.name);
        controlGroup.addClass('error');
        controlGroup.find('.help-inline').text(error.message);
    }, this);
},

hideErrors: function () {
    this.$('.control-group').removeClass('error');
    this.$('.help-inline').text('');
}
</pre>    <p>        Let's test the code. As all fields are left empty, it will look like,<br />
    </p>    <a href="https://lh3.googleusercontent.com/-qPbTz5Cl0N4/UJtgc8JU-1I/AAAAAAAALnU/ru1sJb6j6V4/s717/image-2.png"><br />
        <img src="https://lh3.googleusercontent.com/-qPbTz5Cl0N4/UJtgc8JU-1I/AAAAAAAALnU/ru1sJb6j6V4/s717/image-2.png"></img><br />
    </a><br />
    <p>        As fields are filled and form submitted, all errors are cleared from form.<br />
    </p>    <h2>Conclusions</h2>    <p>        That was very simple "baby-step" style of approaching model validation. I would could it, validation "from the box". Even if it's very useful there are a lot of different approaches of making even things better. The source code is availble on <a href="https://gist.github.com/4037415">github</a>.<br />
    </p>    <p>        Stay tuned for next Backbone.js baby steps soon.<br />
    </p></div>
