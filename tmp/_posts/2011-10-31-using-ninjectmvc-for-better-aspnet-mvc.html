---
layout: post
title: "Using Ninject.MVC For Better ASP.NET MVC Integration"
date: 2011-10-31T16:42:00+02:00
comments: false
categories:
 - MVC
 - asp.net
---

<div class='post'>
<p>After the ASP.NET MVC infrastructure is <a href="http://www.beletsky.net/2011/10/integrating-aspnet-mvc-into-legacy-web.html">ready</a>, next logical step it to setup IoC container for application. Ninject setup is easy task, usually you solve that by implementation of your own <a href="http://www.beletsky.net/2011/07/inside-aspnet-mvc-controllerbuilder.html">ControllerFactory</a> and put it to <a href="http://www.beletsky.net/2011/07/inside-aspnet-mvc-controllerbuilder.html">ControllerBuilder</a>. As soon it is good enough approach it does not solve some important MVC implications, like injection of prosperities into filters. To make our lives a little easier Ninject team released <a href="https://github.com/ninject/ninject.web.mvc">Ninject.Web.MVC</a> extension library that solves a lot of similar problems.<br />
</p><h2>Getting binaries</h2><p>Just follow the github to <a href="https://github.com/ninject/ninject.web.mvc/downloads">download</a> latest version of Ninject.Web.MVC and place it to web site <code>/Bin</code> directory. No changes to <code>web.config</code> or something.<br />
</p><h2>Tweaking global.asax</h2><p>Now, let's change <code>global.asax</code> according to Ninject.Web.MVC guidelines. I'll just show how my current <code>global.aspx</code> looks like:<br />
</p><pre class="brush: xml">&lt;%@ Application Language='C#' Inherits=&quot;Ninject.Web.Mvc.NinjectHttpApplication&quot; %&gt;
&lt;%@ Import Namespace=&quot;Ninject&quot; %&gt;

&lt;script RunAt=&quot;server&quot;&gt;
 public void Application_Start()
 {

 }

 protected override void OnApplicationStarted()
 {
  AreaRegistration.RegisterAllAreas();
 }
 
 protected override IKernel CreateKernel()
 {
  var kernel = new StandardKernel();
  Sba.Web.Infrastructure.RegisterServices.For(kernel);
  
  return kernel;
 }

 public void Application_End()
 {
 }

 public void Application_Error(object sender, EventArgs args)
 {
 }
&lt;/script&gt;
</pre><p>So, we basically inherit from <code>NinjectHttpApplication</code> class and override <code>CreateKernel()</code> method. You can see that inside the method I do call to <code>RegisterServices</code> - it is nothing more as static class, with <code>For</code> method that actually do the registration. Here is example:<br />
</p><pre class="brush: csharp">using Ninject;
using Ninject.Web.Mvc;
using Sba.Common.Repositories;
using Sba.Sales.Models;
using Sba.Sales.Repositories;
using Sba.Sales.Repositories.ViewHandlerRepositories;

namespace Sba.Web.Infrastructure
{
 public class RegisterServices
 {
  public static void For(IKernel kernel)
  {
   kernel.Bind&lt;ISessionLoader&gt;().To&lt;LazySessionLoader&gt;();
   kernel.Bind&lt;ILazyLoadChecker&gt;().To&lt;NHibernateLazyLoadChecker&gt;();
   kernel.Bind&lt;IDraftInvoicesRepository&gt;().To&lt;DraftInvoicesRepository&gt;();
   kernel.Bind&lt;IDraftInvoiceLinesRepository&gt;().To&lt;DraftInvoiceLinesRepository&gt;();
   kernel.Bind&lt;IPaymentTermsRepository&gt;().To&lt;PaymentTermsRepository&gt;();
   kernel.Bind&lt;IUnitsRepository&gt;().To&lt;UnitsRepository&gt;();
   kernel.Bind&lt;ICustomersRepository&gt;().To&lt;CustomersRepository&gt;();
  }
 }
}
</pre><h2>Injection the properties into filters</h2><p>The main advantage of <code>NinjectHttpApplication</code> class usage, that now it handles the injection in different MVC entities by itself. For instance if you need inject to filter:<br />
</p><pre class="brush: csharp">using System.Web.Mvc;
using Ninject;
using Economic2.Core;
using Sba.Common.Repositories;

namespace Sba.Common.Infrastructure.Filters
{
 public class SbaAuthorizeAttribute : AuthorizeAttribute
 {
  [Inject]
  public ISessionLoader SessionLoader { get; set; }

  public override void OnAuthorization(AuthorizationContext filterContext)
  {
            // some authorization logic here..
  }
 }
}
</pre></div>
