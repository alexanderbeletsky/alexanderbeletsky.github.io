---
layout: post
title: "Inside ASP.NET MVC: Route to MvcHandler"
date: 2011-06-06T10:28:00+03:00
comments: false
categories:
 - InsideMVC
 - MVC
 - asp.net
---

<div class='post'>
<p>
In my <a href="http://www.beletsky.net/2011/05/inside-aspnet-mvc-setting-up-project.html">previous post</a> I promised to start with exploration of <code>MvcHanlder</code> as entry point of ASP.NET MVC application. <code>MvcHandler</code> plays the major role in MVC infrastructure, but as I fugured out - the whole story does not begin there. The story is actually begins inside ASP.NET framework.
</p>
<h2>ASP.NET framework</h2>
<p>
ASP.NET framework is heart of ASP.NET MVC application. Basically, ASP.NET is a request processing engine. It takes incoming request as input and sends it through <i>internal pipeline</i> till the <i>end point</i>. The architecture allows extensibility, you could plug either into pipeline (modules) or end points (handlers). Interesting fact that ASP.NET designed to be decoupled from actual request source. So, the source of request could be any application - IIS, Cassini or any custom one.
</p>
<p>
We could imagine that each request pass through the set of filters (<i>internal pipeline</i>) lands up on request handler (<i>end point</i>), request handler creates a response object and sent it back. There are a lot of hidden details of dealing with managed/unmanaged code that you could find in this <a href="http://www.west-wind.com/presentations/howaspnetworks/howaspnetworks.asp">brilliant article</a> by Rick Strahl. 
</p>
<p>
For us it is important to understand two basic abstractions, HttpModules and HttpHandlers.
</p>
<h2>HttpModules and HttpHandlers</h2>
<p>
From the developers point of view the difference between those are: one implements <code>IHttpModule</code> interface another implements <code>IHttpHandler</code> interface. 
</p>
<p>
<strong>Module</strong> participates in the request processing of every request in order to change or add to it in some way.  
</p>
<p>
<strong>Handler</strong> is responsible for handling the request and producing the response for specific content types.  
</p>
<p>
ASP.NET MVC is HttpHandler. 
</p>
<a href="https://lh3.googleusercontent.com/-8EBxpoh7R0w/Tex-Zo80FfI/AAAAAAAAHc8/eMI-FEEurCg/mvchandler.png">
<img src="https://lh3.googleusercontent.com/-8EBxpoh7R0w/Tex-Zo80FfI/AAAAAAAAHc8/eMI-FEEurCg/mvchandler.png" alt="MVC handler" />
</a>
<p>
There a bunch of default HttpModules and HttpHandlers in your IIS configuration. Just take a look here - %WINDOWS%\Microsoft.NET\Framework\v4.0.30319\Config\web.config. 
</p>
<p>
But if you look closer you won't notice any mention of <code>System.Web.Mvc.MvcHanlder</code>. Hey. what's wrong? How the runtime actually knows that <code>MvcHanler</code> have to be called to handle our request? That was absolutely unclear to me at very beginning. 
</p>
<h2>From request to handler</h2>
<p>
I opened WebRuntime.sln and found all references to <code>MvcHandler</code>. It is only one place there, in the <code>MvcRouteHandler</code> (MvcRouteHandler.cs) class. MvcRouteHandler implements <code>IRouteHandler</code> interface, with one single method <code>GetHttpHandler</code>. I put the breakpoint there and started application for debug.
</p>
<a href="https://lh6.googleusercontent.com/-qcToxPI6g3o/Tex-ZsGfgdI/AAAAAAAAHdA/9SLS0GaX5GQ/mvcroutehandler.get.png">
<img src="https://lh6.googleusercontent.com/-qcToxPI6g3o/Tex-ZsGfgdI/AAAAAAAAHdA/9SLS0GaX5GQ/mvcroutehandler.get.png" alt="MVC route handler" />
</a>
<p>
As application got started I halted on breakpoint with such call stack:
</p>
<a href="https://lh4.googleusercontent.com/-95WwV5VbvNA/Tex-ZV9WcgI/AAAAAAAAHc4/RK9EdEXJS3E/s912/gethandler.debug.png">
<img src="https://lh4.googleusercontent.com/-95WwV5VbvNA/Tex-ZV9WcgI/AAAAAAAAHc4/RK9EdEXJS3E/s912/gethandler.debug.png" alt="MVC debug" />
</a>
<p>
Let's try to read and decrypt it.
</p>
<p>
It begins with <code>WebDev.WebHost40.dll</code> (Cassini Web Server) that receives request and <code>System.Web.HttpRuntime.ProcessRequest</code>. Here is ASP.NET framework start to work:  
</p>
<ol>
<li>
<strong>ProcessRequestInternal</strong> method called. This is the primary method of whole pipeline. First, it initialize the <code>HttpContext</code> object.
</li>
<a href="https://lh5.googleusercontent.com/-T9pgTJlG10Q/Tex-Z8zRAGI/AAAAAAAAHdM/duxzWFuPwy0/processrequestinternal.1.png">
<img src="https://lh5.googleusercontent.com/-T9pgTJlG10Q/Tex-Z8zRAGI/AAAAAAAAHdM/duxzWFuPwy0/processrequestinternal.1.png" alt="System.Web.Dll ProcessRequestInternal"/>
</a>
<li>
Next it get <code>HttpApplication</code> instance, initialize it and calls either <code>BeginProcessRequest</code> for <code>IHttpAsyncHandler</code> or <code>ProcessReques</code> for <code>IHttpHandler</code>. 
</li>
<a href="https://lh5.googleusercontent.com/-E2zMvxF0Kjs/Tex-Z399b2I/AAAAAAAAHdE/uuZWDF99pLg/processrequestinternal.2.png">
<img src="https://lh5.googleusercontent.com/-E2zMvxF0Kjs/Tex-Z399b2I/AAAAAAAAHdE/uuZWDF99pLg/processrequestinternal.2.png" alt="System.Web.dll GetApplicationInstance"/>
</a>
<li>
If I go to <code>global.asax.cs</code> of our application it is clear that <code>System.Web.HttpApplication</code> implementation is inherited and <code>System.Web.HttpApplication</code> is a usual <code>IHttpAsyncHandler</code>. So, async <code>BeginProcessRequest</code> starts.
</li>
<a href="https://lh3.googleusercontent.com/-o9FWdeP1IRk/Tex-ZYGZAmI/AAAAAAAAHcw/M9vfv2DB6EM/httpapplication.png">
<img src="https://lh3.googleusercontent.com/-o9FWdeP1IRk/Tex-ZYGZAmI/AAAAAAAAHcw/M9vfv2DB6EM/httpapplication.png" alt="HttpApplication"/>
</a>
<li>In <code>BeginProcessRequest</code> there is a cycle that iterates all modules and execute each of it. Reflector code looks messy, but the point is clear</li>
<a href="https://lh5.googleusercontent.com/-9wj99HDJiOM/Tex-ZEIIEqI/AAAAAAAAHcs/DV6Qy3ewRMM/execute.steps.png">
<img src="https://lh5.googleusercontent.com/-9wj99HDJiOM/Tex-ZEIIEqI/AAAAAAAAHcs/DV6Qy3ewRMM/execute.steps.png" alt="System.Web.dll ExecuteSteps"/>
</a>
<li>And finally, the control goes to <strong>UrlRoutingModule</strong> that calls our factory method for <code>MvcHandler</code>. Aha!</li>
</ol>
<h2>UrlRouting module</h2>
<p>
UrlRouting is an HttpModule, registered in global web.config:
</p>
<a href="https://lh3.googleusercontent.com/-tb3Q5OzOn2k/Tex-aX1BawI/AAAAAAAAHdU/4AFsqAMjD_A/urlrouting.register.png">
<img src="https://lh3.googleusercontent.com/-tb3Q5OzOn2k/Tex-aX1BawI/AAAAAAAAHdU/4AFsqAMjD_A/urlrouting.register.png" alt="UrlRouting register"/>
</a>
<p>
The goal of this module is basically matching incoming request by URL with pre-defined Route configuration and return corresponding handler for this request. In <code>PostResolveRequestCache</code> method it gets the RouteHandler and asks for corresponding HttpHanlder. 
</p>
<a href="https://lh4.googleusercontent.com/-n1rd7SudO7k/Tex-aBhr-tI/AAAAAAAAHdQ/XaEaL3dPmJY/urlrouting.postresolve.png">
<img src="https://lh4.googleusercontent.com/-n1rd7SudO7k/Tex-aBhr-tI/AAAAAAAAHdQ/XaEaL3dPmJY/urlrouting.postresolve.png"/>
</a>
<p>
Wow, I didn't know that!.. UrlRouting plays a major role inside the MVC infrastructure. But there the Routes are initialized and how <code>MvcRouteHandler</code> is associated with request?
</p>
<h2>Back to roots - Application_Start() method</h2>
<p>
I should actually start from here, <code>Application_Start()</code> is entry point of application. By my journey turn to be just other way around.
</p>
<a href="https://lh3.googleusercontent.com/-BTvRzBgusNQ/Tex-Y-X7yrI/AAAAAAAAHcg/0FJT4hP1FM4/applicationstart.png">
<img src="https://lh3.googleusercontent.com/-BTvRzBgusNQ/Tex-Y-X7yrI/AAAAAAAAHcg/0FJT4hP1FM4/applicationstart.png" alt="Application_Init()"/>
</a>
<p>
Inside the <code>RegisterRoutes</code> we register route by giving: route name and constraints.
</p>
<a href="https://lh5.googleusercontent.com/-iKaDvwunU-M/Tex-ZftTanI/AAAAAAAAHc0/6ssXZ32Zva0/maproute.png">
<img src="https://lh5.googleusercontent.com/-iKaDvwunU-M/Tex-ZftTanI/AAAAAAAAHc0/6ssXZ32Zva0/maproute.png" alt="MVC map route"/>
</a>
<p>
The <code>MapRoute</code> is actually extension method in RouteCollectionExtensions.cs.
</p>
<a href="https://lh5.googleusercontent.com/-qvU8dVWiIpw/Tex-aJuc0RI/AAAAAAAAHdI/u3OgdJCf8EA/routecollection.png">
<img src="https://lh5.googleusercontent.com/-qvU8dVWiIpw/Tex-aJuc0RI/AAAAAAAAHdI/u3OgdJCf8EA/routecollection.png" alt="MVC register route"/>
</a>
<p>
Now, you can see how the route with particular URL is being register and associated with <code>MvcRouteHandler</code>.
</p>
<h2>Putting it all together</h2>
<p>
Now it is time to get deep breath and finally understand the route of HTTP request to MvcHttpHandler. Here we go:
</p>
<ul>
<li>ASP.NET framework starting to process incoming request in <code>ProcessRequest</code> method, but interesting stuff going in <code>ProcessRequestInternal</code></li>
<li><code>ProcessRequestInternal</code> calls <code>GetApplicationInstance</code> method that get application instance and calls it <code>Application_Init()</code></li>
<li><code>Application_Init()</code> registers routes that map URL (like "home/index") with <code>MvcRouteHandler</code> instance</li>
<li>ASP.NET framework starts to iterate modules for incoming request and found <code>UrlRouting</code> module</li>
<li><code>UrlRouting</code> module matches incoming request URL with registered collections of Routes</li>
<li>For found matched Route it gets corresponding route handler (MvcRouteHandler)</li>
<li><code>MvcHandler</code> is being returned by GetHttpHandler of MvcRouteHandler</li>
</ul>
<p>
That's the routing that is being executed each time you put URL and hit your browser button.
</p>
<h2>What's next?</h2>
<p>
I hope next time we indeed look closer to <code>MvcHandler</code> :).
</p>
<p>
Previous: <a href="http://www.beletsky.net/2011/05/inside-aspnet-mvc-setting-up-project.html">Inside ASP.NET MVC: Part 2: Setting up project for hacking</a>
Next: <a href=http://www.beletsky.net/2011/06/inside-aspnet-mvc-all-begins-here.html">Inside ASP.NET MVC: All begins here - MvcHanlder</a>
</p></div>
