<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | Alexander Beletsky's development blog]]></title>
  <link href="http://alexanderbeletsky.github.io/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://alexanderbeletsky.github.io/"/>
  <updated>2013-09-11T12:47:43+02:00</updated>
  <id>http://alexanderbeletsky.github.io/</id>
  <author>
    <name><![CDATA[Alexander Beletsky]]></name>
    <email><![CDATA[alexander.beletsky@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Playing with Dokku on Vagrant]]></title>
    <link href="http://alexanderbeletsky.github.io/2013/09/playing-with-dokku-on-vagrant.html"/>
    <updated>2013-09-03T19:57:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2013/09/playing-with-dokku-on-vagrant</id>
    <content type="html"><![CDATA[<p>As I said <a href="http://beletsky.net/2013/08/digitalocean-plus-dokku-equals-10-heroku.html">previously</a>, it&rsquo;s very easy to turn Linux machine into Heroku-like server. But, before setting up paying account on Amazon or Digital Ocean, it&rsquo;s nice to just play it locally. Will do that, running a Dokku on virtual machine. Will setup development environment and do first local deployment, just to see some real features.</p>

<p>It does not require complex environment to run Dokku locally. All you need is <code>git</code> and <code>Vagrant</code>.</p>

<!-- More -->


<h2>Prepearing Environment</h2>

<p>You box should contain few things: git (github account), VirtualBox and Vagrant. If you don&rsquo;t have Vagrant installed, please do now. It makes a lot of sense to keep such kind software on machine.</p>

<p>Here you can find <a href="http://docs.vagrantup.com/v2/getting-started/index.html">some instructionn</a> of how to do that.</p>

<h3>Cloning Dokku</h3>

<p>You should clone Dokku repo locally. In your development folder, run</p>

<p>```bash</p>

<blockquote><p>git clone git@github.com:progrium/dokku.git
cd dokku
```</p></blockquote>

<p>Dokku repository already contains Vagrant file, with all required configuration.</p>

<h3>Local Networking</h3>

<p>Just in sake of convenience, will map <code>10.0.0.2</code> ip address (the one that Vagrant machine is assigned with), to <code>dokku.me</code> DNS name, so it&rsquo;s just handy for testing.</p>

<p><code>bash
› sudo nano /private/etc/hosts
</code></p>

<p>and put last 2 lines, as it shown in my example:</p>

<p>```plain</p>

<h1>#</h1>

<h1>Host Database</h1>

<p>#</p>

<h1>localhost is used to configure the loopback interface</h1>

<h1>when the system is booting.  Do not change this entry.</h1>

<h1>#</h1>

<p>127.0.0.1       localhost
255.255.255.255 broadcasthost
::1             localhost
fe80::1%lo0     localhost
10.0.0.2        dokku.me
10.0.0.2        node-simple.dokku.me
```</p>

<h3>Fire Up Virtual Machine</h3>

<p>In <code>dokku</code> folder, you should run</p>

<p>```bash</p>

<blockquote><p>vagrant up
```</p></blockquote>

<p>It will start to prepare new virtual environment for you,</p>

<p><code>bash
 vagrant up
Bringing machine 'default' up with 'virtualbox' provider...
[default] Setting the name of the VM...
[default] Clearing any previously set forwarded ports...
[default] Creating shared folders metadata...
[default] Clearing any previously set network interfaces...
[default] Preparing network interfaces based on configuration...
[default] Forwarding ports...
[default] -- 22 =&gt; 2222 (adapter 1)
[default] -- 80 =&gt; 8080 (adapter 1)
[default] Running any VM customizations...
[default] Booting VM...
[default] Waiting for VM to boot. This can take a few minutes.
</code></p>

<p>I have a problem with this step few times, so if you machine could not be booted, try to run <code>vagrant reload</code>, it should help.</p>

<p>It would took about up to 20 minutes, to fire up virtual machine, install git there, install Docker + Dokku. As soon as it&rsquo;s done, it&rsquo;s possible to access machine by <code>ssh</code>.</p>

<p>Last thing you need to do, is to upload your <code>ssh</code> key to Dokku server, so you will be to <code>git push</code> code there.</p>

<p>```bash</p>

<blockquote><p>cat ~/.ssh/id_rsa.pub | ssh <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#114;&#111;&#111;&#x74;&#64;&#100;&#111;&#x6b;&#x6b;&#117;&#x2e;&#x6d;&#101;">&#114;&#x6f;&#x6f;&#x74;&#64;&#100;&#x6f;&#107;&#x6b;&#x75;&#46;&#x6d;&#101;</a> &ldquo;sudo gitreceive upload-key alexanderbeletsky&rdquo;
```</p></blockquote>

<p>You can use default vagrant root password, which is <code>vagrant</code>.</p>

<p>Now, just to check that everything is fine simply access you machine by <code>ssh</code>,</p>

<p>```bash</p>

<blockquote><p>vagrant ssh
```</p></blockquote>

<p>So, just try that everything is running fine by checking version of Docker:</p>

<p>```bash</p>

<blockquote><p>docker -v
Docker version 0.6.1, build 5105263
```</p></blockquote>

<p>The instance is ready for deployment.</p>

<h2>Deploy to Dokku</h2>

<p>If you still there, you can just quit vagrant <code>ssh</code> session, and went to the folder with Node.js application. I&rsquo;ll be using really simple <a href="https://github.com/alexanderbeletsky/node-simple">app</a>, called <code>Node-simple</code> &ndash; express.js based, that serves one HTML file and shows <code>NODE_ENV</code> env. variable.</p>

<p>So, what you need to setup is remote repository to push to:</p>

<p>```bash</p>

<blockquote><p>git remote add local-deploy git@dokku.me:node-simple
```</p></blockquote>

<p>That&rsquo;s all. You ready for first deploy, just push code to machine with Dokku:</p>

<p>```bash
git push local-deploy master
› git push local-deploy master &mdash;force
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 289 bytes | 0 bytes/s, done.
Total 3 (delta 2), reused 0 (delta 0)
&mdash;&mdash;&ndash;> Building node-simple &hellip;</p>

<pre><code>   Node.js app detected
</code></pre>

<p>&mdash;&mdash;&ndash;> Resolving engine versions</p>

<pre><code>   Using Node.js version: 0.8.25
   Using npm version: 1.2.30
</code></pre>

<p>&mdash;&mdash;&ndash;> Fetching Node.js binaries
&mdash;&mdash;&ndash;> Vendoring node into slug
&mdash;&mdash;&ndash;> Installing dependencies with npm</p>

<pre><code>   npm WARN package.json application-name@0.0.5 No repository field.
   npm WARN package.json application-name@0.0.5 No readme data.
   npm WARN package.json send@0.1.0 No repository field.
   ...
</code></pre>

<p>=====> Application deployed:</p>

<pre><code>   http://node-simple.dokku.me
</code></pre>

<p>To git@dokku.me:node-simple
   dd05aae..ac5b6da  master &ndash;> master
```</p>

<h2>Setting up Environment</h2>

<p>Every application requires environment. It&rsquo;s common practice to set at least <code>NODE_ENV</code> variable for Node.js applications. To do that, you need to create <code>ENV</code> file inside the <code>/home/git/node-simple</code> folder.</p>

<p><code>bash
› ssh root@dokku.me "echo export NODE_ENV="development" &gt; /home/git/node-simple/ENV"
</code></p>

<p>Now, let&rsquo;s re-deploy the application, change the version in <code>package.json</code> and push code again.</p>

<p><code>bash
› git push local-deploy master
</code></p>

<p>Now, application is ready to be accessed.</p>

<h2>Accessing the Application</h2>

<p>Open Chrome and hit <code>http://node-simple.dokku.me</code>, so you will see such response:</p>

<p><img src="/images/blog/node-simple-run.png"></p>

<p>You can play a bit further, by just changing some Node.js code of end-points and re-deploy. Each time, new docker instance is started and served on <code>http://node-simple.dokku.me</code>. The experience of deployment is really like something you have with Heroku.</p>

<p>Just looking on logs while new application is deployed, would give pretty much idea of what&rsquo;s going on there.</p>

<p>So, your local Vagrant image will good start place, before you ready to use Dokku on cloud.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Digital Ocean + Dokku = 10$ Heroku]]></title>
    <link href="http://alexanderbeletsky.github.io/2013/08/digitalocean-plus-dokku-equals-10-heroku.html"/>
    <updated>2013-08-28T22:00:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2013/08/digitalocean-plus-dokku-equals-10-heroku</id>
    <content type="html"><![CDATA[<p>My last infrastructure related <a href="http://beletsky.net/2013/07/why-we-moved-from-appfog-to-nodejitsu.html">post</a> was about an experience of using AppFog and switching to Nodejitsu eventually. But that was not the end. In short: for <a href="https://likeastore.com/">Likeastore</a> we needed SSL support, it happed that SSL is only available for Nodejitsu business plan, which price is 120 USD. That was simply to much for our small venture.</p>

<p>Long time ago, I realized &ndash; constrains are good. This case just proved that. Looking for alternative options, gave really nice results, which I easily could be re-used if you looking for simple deployment solutions.</p>

<!-- More -->


<h2>Heroku</h2>

<p>Heroku is good service. Afraid to be mistaken, but that&rsquo;s probably Heroku who popularized &ldquo;git-powered&rdquo; deployments much, ones there deployment script looks like:</p>

<p>```bash</p>

<blockquote><p>git push heroku master
```</p></blockquote>

<p>The rest is all about the service &ndash; prepare runtime, deploy code, start web application etc. Besides of that Heroku open-sourced a lot of good stuff, including so called <a href="https://devcenter.heroku.com/articles/buildpacks">buildpacks</a>, some ready to use scripts that are able to setup the dyno with all required runtime to be able to start application there.</p>

<p>I never seriously used Heroku, though. What I dislike, is pricing. Also, the other people I asked about their satisfaction of using Heroku, was not satisfying much (arguable). We needed more lightweight, easy to change setup.</p>

<h2>Digital Ocean</h2>

<p><a href="https://www.digitalocean.com/?refcode=de56d081b272">Digital Ocean</a> is very fast growing cloud-computing service. It&rsquo;s not PaaS (platform as a service) like Heroku, it&rsquo;s rather IaaS (infrastructure as a service). They are notable for few major things:</p>

<ul>
<li><strong>Pricing</strong> &ndash; really (mean, really!) competitive pricing, 1GB RAM, 30GB SSD machine for 10$.</li>
<li><strong>Easy of use</strong> &ndash; the flow from registration for first droplet creation is smooth and clear.</li>
<li><strong>Regions</strong> &ndash; machines can be fired up for both US and EU, ideal for us.</li>
</ul>


<p>But again, Digital Ocean is nothing more as great infrastructure. Herding the server is all up to you. I personally was really afraid of that perspective of setting up nginx, configuring firewalls, load-balancing etc., that prevented me to look to Digital Ocean closely. Getting used to deployment procedures with Nodejitsu and Heroku, it&rsquo;s real pain to deploy app by FTP again and do everything manually.</p>

<p>But lucky chance I noticed <a href="https://github.com/progrium/dokku">Dokku</a> project and that was something really great, explain why later.</p>

<h2>Dokku &amp; Docker</h2>

<p>So, <a href="https://github.com/progrium/dokku">Dokku</a> is simply amazing hack (or more correctly, combination of diffrent hacks) by <a href="https://github.com/progrium">Jeff Lindsay</a>. Some initial facts:</p>

<ul>
<li>Written in Shell script and currently nearly 100 lines of code</li>
<li>Based on Docker</li>
<li>Provides Heroku-like deployment experience</li>
<li>Community-driven</li>
</ul>


<p>Dokku, can be installed to Ubuntu 13 machine and turn that machine into Heroku-like server. I mean, you can push the code there and Dokku, will fire-up new <em>docker process</em>, deploy code there, start the application, configure nginx and setup environment variables and SSL.</p>

<p>Btw, the time I just looked to Dokku, they missed exactly support of ENV variables and SSL. It was not acceptable for me, without those 2 features. Constraints again, but that gave me ability to contribute the projects and eventually I submitted both features.</p>

<p>Dokku, is very interesting project. First of all, because it based on trendy <a href="http://www.docker.io/">Docker</a>. Docker is &ldquo;Virtual-Machine-Based-Deployment&rdquo; alternative. Deployment on virtual boxes are de-facto standard now and docker is about to change that. Guys from <a href="https://www.dotcloud.com/">dotCloud</a> open-sourced solution that allows to run isolated processes (containers) &ndash; that are like lightweight virtual machines. You can deploy docker on Ubuntu server and then use that as host any kind of applications or databases.</p>

<p>Docker could turn Ubuntu Server to PaaS and Dokku makes great &ldquo;interface&rdquo; for that.</p>

<p>Each Dokku piece is very interesting indeed and I hope to blog more about. And Dokku is using Heroku buildbacks, which makes you feel you deal with Heroku, not with your own setup.</p>

<h2>Putting Things Together</h2>

<p>Digital Ocean and Dokku make a perfect match. As I said above, Digital Ocean is something you can really start quick with. So, what we did is just started up 10$ Ubuntu 13 server and installed Dokku there. In total it took 7 minutes or so. I would not bother you with instructions, cause you find a lot in <a href="https://medium.com/code-adventures/438bce155dcb">internet</a>.. but also, assuming that DO + Dokku is a kind of Apple product, that does not require instructions.</p>

<p>First impression was simply amazing. You have everything under control and fill great with &ldquo;git-powered&rdquo; deployments. So, after successful try that machine became our staging server and I also fired-up another one for production one.</p>

<p>Now, then we developing features and what to show each other or test, you just need to do following:</p>

<p>```bash</p>

<blockquote><p>git push deploy-staging feature:master
Counting objects: 7, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 445 bytes | 0 bytes/s, done.
Total 4 (delta 2), reused 0 (delta 0)
remote: &mdash;&mdash;&ndash;> Building collector &hellip;
remote:        Node.js app detected
remote: &mdash;&mdash;&ndash;> Resolving engine versions
remote:        Using Node.js version: 0.10.15
remote:        Using npm version: 1.2.30
remote: &mdash;&mdash;&ndash;> Fetching Node.js binaries
remote: &mdash;&mdash;&ndash;> Vendoring node into slug
remote: &mdash;&mdash;&ndash;> Installing dependencies with npm
remote:        npm WARN package.json <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x6c;&#x69;&#107;&#x65;&#x61;&#x73;&#116;&#x6f;&#114;&#101;&#x2d;&#x63;&#x6f;&#108;&#108;&#x65;&#99;&#x74;&#111;&#114;&#64;&#48;&#x2e;&#48;&#46;&#x32;&#x2d;&#x32;&#49;">&#x6c;&#105;&#x6b;&#101;&#97;&#x73;&#x74;&#x6f;&#x72;&#101;&#45;&#x63;&#x6f;&#x6c;&#108;&#101;&#x63;&#116;&#111;&#114;&#64;&#48;&#46;&#48;&#x2e;&#50;&#45;&#50;&#x31;</a> No repository field.
remote:        npm http GET <a href="https://registry.npmjs.org/mongojs">https://registry.npmjs.org/mongojs</a>
remote:        npm http GET <a href="https://registry.npmjs.org/underscore">https://registry.npmjs.org/underscore</a></p></blockquote>

<p>&hellip;</p>

<p>remote: =====> Application deployed:
remote:        <a href="http://stage-collector.likeastore.com">http://stage-collector.likeastore.com</a>
```</p>

<p>The time we are ready to release:</p>

<p>```bash</p>

<blockquote><p>git push deploy-production master
Counting objects: 7, done.
Delta compression using up to 8 threads.
&hellip;</p></blockquote>

<p>remote: =====> Application deployed:
remote:        <a href="http://collector.likeastore.com">http://collector.likeastore.com</a>
```</p>

<p>It&rsquo;s fast and it&rsquo;s pretty reliable.</p>

<p>For conclusion, I would say that using both Digial Ocean and Dokku was a clear win for <a href="https://likeastore.com/">Likeastore</a> being released.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why We Moved From AppFog to Nodejitsu]]></title>
    <link href="http://alexanderbeletsky.github.io/2013/07/why-we-moved-from-appfog-to-nodejitsu.html"/>
    <updated>2013-07-19T19:36:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2013/07/why-we-moved-from-appfog-to-nodejitsu</id>
    <content type="html"><![CDATA[<p><a href="http://likeastore.com/">Likeastore</a> started to use <a href="https://www.appfog.com/">AppFog</a> as PaaS during private beta campaign. That was great idea initially since AppFog offers really nice conditions: 8 running instances with 256MB or RAM, custom domain names, support and all relative services. I have to say, it did work fine at the beginning, allowing us to push product forward and show it to our subscribers.</p>

<p>But very fast we realized that AppFog does not suite us at lot.</p>

<!--More-->


<h2>Why to mess up with PaaS?</h2>

<p>If you never tried things like <a href="https://www.heroku.com/">Heroku</a>, <a href="https://www.appfog.com/">AppFog</a>, or <a href="https://appharbor.com/">AppHabor</a> you might have a question, why to pay for something you &ldquo;almost&rdquo; can do your self just by renting VPS.</p>

<p>Renting VPS seems to be nice idea, but the problem is &ndash; you taking to much responsibility to manage the server by your own. You have to have certain skills to configure nginx, git repositories, ssh keys etc. It&rsquo;s possible to do, but it takes a lot time.. time you can spend on code something will be spend to configure something.</p>

<p>Another very important point is deployments. Usually deployments are hard and time consuming, since you have to do them manually. But with PaaS all you have to do to deploy the up is either, <code>git push</code> to some remote repo.. or call a special script like <code>af push app</code>, to do all the magic.</p>

<p>For small companies and side-projects PaaS is a really good opportunity to actually ship something, instead of fail to customize the web server.</p>

<h2>Why AppFog?</h2>

<p>I&rsquo;ve heard about AppFog before from twitter and hacker news. It looked very attractive.</p>

<p>But it was not the only one on the market. So, really competitive feature for me was: 8 running instances, for 20 USD. Very good price. We need 4 at that time, so AppFog was very good choice.</p>

<p>But as always, with time you start to see some negative moments. Something that lead us to finally drop AppFog. I would like to quickly go through good and less good things.</p>

<h2>Dashboard and UI</h2>

<p>AppFog dashboard is quite nicely designed. But sometimes I felt difficulties to just find the things.</p>

<p>I was not happy with performance of dashboard as well. It was really slow for me usually, so you click to check instance state and wait for 30 seconds while the page opens. You can leave with that, but the time comes than you start to hate it.</p>

<h2>AppFog CLI</h2>

<p>To create / run / stop applications on AppFog, you get a special command line utility, called <code>af</code>. It&rsquo;s typically for all PaaS to have some CLI to communicate to it. It&rsquo;s easy to install and configure, everything is nice.</p>

<p>It&rsquo;s written on Ruby, so you won&rsquo;t have any problems on Mac, but Ruby have to installed on Windows machine.</p>

<p>Once it&rsquo;s installed you have to login to you AppFog account and start to deploy.</p>

<h2>Deployment experience</h2>

<p>Even if CLI itself was quite nicely done, deployment experience was not so nice &ndash; it was too slow.</p>

<p>Node.js is deployment-friendly platform. No build steps, no linking, no packaging &ndash; nothing. All you have to do, is to push the sources to remote machine. Sure, PaaS is doing a lot magic behind the scences, like firing new virtual machines and configuring network interfaces etc.</p>

<p>And all that magic for AppFog works too long.</p>

<p>Deployment could took up to 40 seconds, which is fine if you do it once in week. But it bothers you a lot while you do that once in hour.</p>

<h2>Release management</h2>

<p>If your plan is continuous delivery and frequent deployments, you have to be ready for frequent rollbacks as well. Without that feature, you are in trouble.</p>

<p>AppFog does not afford anything like that. Correctly say, you have to do it manually, like tagging sources, then fetching by tag and push again.</p>

<p>That&rsquo;s not big issue, I would say. Nevertheless, developers are too optimistic thinking that everything works great (and indeed in always works fine, on my machine), but the time you see issues on production you just panic and loosing control of what to do.</p>

<h2>Support</h2>

<p>Even if you running tiny bussiness and no one hurt if your application is down, still you expect that you&rsquo;ll get help if you are in trouble. That&rsquo;s the whole idea of support, especially if you pay money for it.</p>

<p>AppFog support is not good. Few times my tickets were unanswered for 2 days. Then they answered I found the reason or was able to fix it by myself.</p>

<p>This is just makes very bad impression of service. You start to think, it&rsquo;s not so reliable, so the time you&rsquo;ll be really screwed, they won&rsquo;t come help.</p>

<h2>Load balancing and cookies</h2>

<p>So, all mentioned above is something that we would prioritize as &ldquo;cosmetic&rdquo; issues. A bit ugly, but you can leave with it. The real and unexpected problem appeared as we did first announcement and users came to check the application.</p>

<p>We are using <a href="">passport</a> for user authorization, which depends on sessions. Each request contains contains a <code>session_state</code> which being persisted in cookie. The problem was that, on AppFog for some unknown dropped that <code>session_state</code>. So, after user just logged on and clicked somewhere, she was immediately redirected back to login page, as unauthorized.</p>

<p>Absolutely unclear behavior to me.</p>

<p>I definitely know I&rsquo;m not the <a href="https://www.google.com/search?q=appfog+session+lost&amp;oq=appfog+session+lost">only one</a> who was suffering that issue. Supported failed to answer quickly and even on my next request they didn&rsquo;t provide anything constructive.</p>

<p>That was the show-stopper with AppFog.</p>

<h2>.. and now Nodejitsu?</h2>

<p>Meanwhile, I just deployed application to <a href="">Nodejtsu</a> and it worked fine there. I was really happy to see the features I missed with AppFog:</p>

<ul>
<li>Clear and fast dashboard</li>
<li>Release management (you can go back and forth with any version you deployed)</li>
<li>Node.js written CLI and fast deployments</li>
<li>Good support</li>
</ul>


<p>The time we joined Nodejitsu it costs 33 USD for 3 instances, that didn&rsquo;t match our needs ideally, but we had to embrace the constraints.</p>

<h2>Conclusions</h2>

<p>I know, there is nothing ideal in this world &ndash; but if you have choice, it&rsquo;s fine pick up best (or at least better). I would not say AppFog completely sucks, but it didn&rsquo;t work for me as I was expecting.</p>

<p>PS. While writing this post I&rsquo;ve noticed that AppFog being <a href="https://www.appfog.com/savvis/">acquired</a> by CentruLink. I only wish that it would positively affect service and support, so wish good luck for AppFog.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Think Ahead, Think Logging]]></title>
    <link href="http://alexanderbeletsky.github.io/2013/07/think-ahead-think-logging.html"/>
    <updated>2013-07-04T09:02:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2013/07/think-ahead-think-logging</id>
    <content type="html"><![CDATA[<p>When we develop application, we have everything to understand applications behavior. Debugger, traces, tests &ndash; all information just in hands. If something goes wrong, it&rsquo;s not so hard to track the problem.</p>

<p>Situation is completely different then app leaves development box and goes to production. In best case, we&rsquo;ll receive email or tweet from user, but typically problem remains on production <em>silently</em>, while customers just <em>silently</em> leave.</p>

<p>Prepare application to production, means prepare good error logging. I&rsquo;m going to show how to extend your Express.js with proper logs.</p>

<!-- More -->


<h2>What it means to have good logs?</h2>

<p>In my perspective good logs are ones satisfying following criterias:</p>

<ul>
<li>All unhandled errors are logged</li>
<li>Log records are comprehensive and clear</li>
<li>Logs are easily accessible</li>
<li>If critical error logged, developers have to be notified</li>
</ul>


<h2>Logger</h2>

<p>Logger is object responsible to take some message or object and log it. The example of one,</p>

<p>```js
var util = require(&lsquo;util&rsquo;);
var colors = require(&lsquo;colors&rsquo;);
var moment = require(&lsquo;moment&rsquo;);</p>

<p>var logger = {</p>

<pre><code>colorsMap: {
    'success': 'green',
    'warning': 'yellow',
    'err': 'red',
    'info': 'grey'
},

success: function (message) {
    this.log('success', message);
},

warning: function (message) {
    this.log('warning', message);
},

error: function (message) {
    this.log('err', message);
},

info: function (message) {
    this.log('info', message);
},

log: function (type, message) {
    var record = this.timestamptMessage(util.format('%s: %s', type.toUpperCase(), this.formatMessage(message)));
    console.log(record[this.colorsMap[type]]);
},

formatMessage: function (message) {
    return typeof message === 'string' ? message : JSON.stringify(message);
},

timestamptMessage: function (message) {
    return util.format('[%s] %s', moment(), message);
}
</code></pre>

<p>};</p>

<p>module.exports = logger;
```</p>

<p><code>Logger</code> could be used everywhere you need to get some info. But our ultimate goal is to be aware of all errors might appear in application.</p>

<h2>Augmenting Express.js application with logs</h2>

<p>We never know then error might appear. But, we can catch all unhandled errors + if some web request failed to complete with success code, we have to log that as well.</p>

<h3>Handling &ldquo;unhandled&rdquo; errors</h3>

<p>We can listen to process &lsquo;uncaughtException&rsquo; event. It just placed in <code>app.js</code> file. The best place is just after require section and before any object is used.</p>

<p>```js
process.on(&lsquo;uncaughtException&rsquo;, function (err) {</p>

<pre><code>logger.error({msg:'Uncaught exception', error:err, stack:err.stack});
</code></pre>

<p>});
```</p>

<p>From official docs,</p>

<blockquote><p>Emitted when an exception bubbles all the way back to the event loop. If a listener is added for this exception, the default action (which is to print a stack trace and exit) will not occur.</p></blockquote>

<p>So, we just redirecting that error to logger. Also, docs say following:</p>

<blockquote><p>Don&rsquo;t use it, use <a href="http://nodejs.org/api/domain.html">domains</a> instead. If you do use it, restart your application after every unhandled exception!</p></blockquote>

<p>I still not switched to domain version for that, need to consider that advice.</p>

<p>Anyway, this <code>uncaughtException</code> will give us only information typically about <code>undefined</code> variables used, that&rsquo;s pretty simple to caught during development testing. More interesting stuff is what&rsquo;s actually happening on runtime, while application handling HTTP requests.</p>

<h3>Logging failing HTTP requests</h3>

<p>Express.js power feature is <em>middleware</em>. It&rsquo;s possible to do a lot of cool stuff based on middleware functions. We&rsquo;ll utilize that feature to create a few middleware function that would allow to log all failed HTTP requests.</p>

<p>First one,</p>

<p>```js
// have to be injected as last middlware function for all routes
function logErrors () {</p>

<pre><code>return function logErrors(err, req, res, next) {
    req.unhandledError = err;

    next(err);
};
</code></pre>

<p>}
```</p>

<p>Second one,</p>

<p>```js
function logHttpErrors () {</p>

<pre><code>return function logHttpErrors (req, res, next) {
    var end = res.end;
    res.end = function (data, encoding) {
        var status = res.statusCode;
        var message = {
            url: res.req.url,
            headers: res.req.headers,
            status: status,
            body: req.body,
            params: req.params
        };

        if (req.unhandledError) {
            message.error = req.unhandledError;
        }

        if (warning(status)) {
            logger.warning(message);
        }

        if (error(status)) {
            logger.error(message);
        }

        end.call (res, data, encoding);
    };

    next();
};

function warning (status) {
    return status &gt;= 400 &amp;&amp; status &lt; 500;
}

function error (status) {
    return status &gt;= 500;
}
</code></pre>

<p>}
```</p>

<p>Look a bit closer: <code>logError()</code> produces middleware function that expected to be the last in chain, and if previous function retured an error, it stores that error object in in requests. <code>logHttpErrors()</code> produces middleware function that would override response <code>.end()</code> function and logs warning or error, depending on response status code.</p>

<p>Let&rsquo;s integrate to app.</p>

<p><code>logHttpErrors()</code> could be put into <code>app.configure()</code> function,</p>

<p>```js
app.configure(function(){</p>

<pre><code>app.set('port', process.env.VCAP_APP_PORT || 3001);
// ...
app.use(middleware.errors.logHttpErrors());
// ...
</code></pre>

<p>});</p>

<p>```</p>

<p>It&rsquo;s a bit more trickier with <code>logError()</code> function. As I said above, it have to be <strong>last</strong> callback in chain.</p>

<p>So, it&rsquo;s only possible to apply it in <code>app.configure()</code> since the routes are not defined yet. Even it&rsquo;s possible to manually add it to each endpoint manually, I don&rsquo;t think it&rsquo;s good idea, because it&rsquo;s easy to forgot do that.</p>

<p>I came up to following solution,</p>

<p>```js
require(&lsquo;./source/api&rsquo;)(app);
require(&lsquo;./source/router&rsquo;)(app);</p>

<p>// here .logError() will be added to end of chain
applyErrorLogging(app);</p>

<p>http.createServer(app).listen(app.get(&lsquo;port&rsquo;), function() {</p>

<pre><code>var env = process.env.NODE_ENV || 'development';
logger.info('Likeastore app listening on port ' + app.get('port') + ' ' + env + ' mongo: ' + config.connection);
</code></pre>

<p>});
```</p>

<p>And <code>applyErrorLogging()</code> function,</p>

<p>```js
var middleware = require(&lsquo;../middleware&rsquo;);</p>

<p>function applyErrorLogging(app) {</p>

<pre><code>for (var verb in app.routes) {
    var routes = app.routes[verb];
    routes.forEach(patchRoute);
}

function patchRoute (route) {
    route.callbacks.push(middleware.errors.logErrors());
}
</code></pre>

<p>}</p>

<p>module.exports = applyErrorLogging;
```</p>

<p>Now, it&rsquo;s everything in place, so all <code>4xx</code> are logged as warnings, all <code>5xx</code> are logged as errors.</p>

<h2>Move your logs to cloud</h2>

<p>Simply logging information is not enough. While your application writes info to console on production machine, this information worthless to you. You have to put you logs to the place where is easily accessible.</p>

<p>There are few services like that. One of I recently hooked with in <a href="https://logentries.com/">Logentries</a>.</p>

<p>Logentries gives you API to submit information there + Dashboard, there logs can be viewed, search and analyzed.</p>

<p><img src="/images/blog/logentries-screen.png" alt="logentries dashboard" /></p>

<p>Install <code>node-logentries</code> client,</p>

<p><code>bash
$ npm install node-logentries --save
</code></p>

<p>And now, we need to update logger, to not only <code>console.log</code> but send it to Logentries.</p>

<p>Will create Logentries client,</p>

<p>```js
var log = logentries.logger({</p>

<pre><code>token:process.env.LOGENTRIES_TOKEN
</code></pre>

<p>});
log.level(&lsquo;info&rsquo;);</p>

<p>```</p>

<p>Will extend existing logger and override current <code>.log()</code> function:</p>

<p>```js
var logentriesLogger = (function (_super) {</p>

<pre><code>var child = {
    log: function (type, message) {
        _super.log(type, message);
        log.log(type, message);
    }
};

return _.extend(Object.create(_super), child);
</code></pre>

<p>})(logger);</p>

<p>module.exports = logentriesLogger;
```</p>

<p>Checkout this <a href="https://gist.github.com/alexanderbeletsky/5921464">gist</a> where you can see all things put together.</p>

<p>So, now wherever <code>logger</code> is used, logs will both shown to screen (which is cool for development) and submitted to Logentries (which is cool for production).</p>

<h2>Setup notification on critical errors</h2>

<p>If error appeared on production, developers attention should be there. Without good notification system, is too easy to skip the moment then error arises.</p>

<p>Again, it&rsquo;s easy to do with Logentries. Just go to <code>Alerts</code> section and setup patterns of errors you interested and email addresses for notifications.</p>

<p><img src="/images/blog/logentries-alerts.png" alt="logentries alerts setup" /></p>

<p>Email is not only one option, you can setup for SMS or webhook for your app. So, anytime error or warning appeared you will be notified and take action on it.</p>

<h2>Conclusions</h2>

<p>I&rsquo;ve used that for <a href="http://likeastore.com">likeastore</a> app I currently working on and it works just fine. Having such logs gave a lot of information after we went to private-beta phase. When you see how application behaves then real users start to use, it gives you good insights about fixes and improvements to apply.</p>

<p>Taking into account that approach above is very universal and easy to adopt, to it today.</p>
]]></content>
  </entry>
  
</feed>
