<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Approvals | Alexander Beletsky's development blog]]></title>
  <link href="http://alexanderbeletsky.github.io/blog/categories/approvals/atom.xml" rel="self"/>
  <link href="http://alexanderbeletsky.github.io/"/>
  <updated>2013-07-04T14:03:03+03:00</updated>
  <id>http://alexanderbeletsky.github.io/</id>
  <author>
    <name><![CDATA[Alexander Beletsky]]></name>
    <email><![CDATA[alexander.beletsky@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Approval Testing for ELMAH.MVC project]]></title>
    <link href="http://alexanderbeletsky.github.io/2012/06/using-approval-testing-for-elmahmvc.html"/>
    <updated>2012-06-16T15:23:00+03:00</updated>
    <id>http://alexanderbeletsky.github.io/2012/06/using-approval-testing-for-elmahmvc</id>
    <content type="html"><![CDATA[<div class='post'>
<p>    During the ELMAH.MVC 2.0 preparation I had a bit challenging task. As I <a href="http://www.beletsky.net/2012/06/elmahmvc-v20-is-coming.html">mentioned</a>, I was about to adopt some code from <a href="http://code.google.com/p/elmah-sandbox/">ELMAH.Sandox</a> project. The 2.0 release included some new features, but what was important to me is make sure I keep previous ELMAH.MVC functionality.<br />
</p><p>    In case you are following my blog, you probably read about <a href="http://www.beletsky.net/search/label/Approvals">Approval.Test</a> framework, which I personally like and recommend to my fellow developers. I did some posts, there I tried to show some Approvals benefits. Today, I'll show some real-life use case.<br />
</p><h2>Installing by NuGet</h2><p>    Last time I played with Approvals, the binaries were only available at SourseForge project page. It is not convenient at all. I was happy to see the tweet from <a href="http://twitter.com/#!/llewellynfalco">Llewellyn Falco</a>, he mentioned that ApprovalTests are now available on <a href="http://nuget.org/packages/ApprovalTests">NuGet</a>. So, installation now as easy as:<br />
</p><div class="commandWrapper">    <div class="commandPrompt">        <p class="command">            PM&gt; Install-Package ApprovalTests<br />
        </p>    </div></div><h2>Thinking of test</h2><p>I had to have some kind of assurance, that I will not break existing ELMAH pages after I switch to new ELMAH controller. Basically, I need to have some 'Master Database' that would contain all logged errors and I need to grab all possible output that is being generated by ELMAH error log page handler. <br />
</p><p>This is what perfectly match the 'Locking Down' testing strategy. In locking down testing, you try to get all possible system output, and approve it. In my case, I wanted to approve that all HTTP calls to ELMAH pages, like '/elmah', '/elmah/stylesheet', '/elmah/rss' and so on, still work as they worked before, meaning producing the same output as they produced before.  <br />
</p><h2>Test implementation</h2><p>For my 'do' step of the the test, I need to collect all possible applications output. I already know all URL's, so I just fired up the site with ELMAH.MVC 1.3.2 version installed. I configured the site to use XML files for storing the tests, so I can easily copy them before each test run. That made a kind of 'Master Database' for me.<br />
</p><p>For the verification, all I need to have is <code>ApprovalTests.Approvals.Verify()</code>.<br />
</p><pre class="brush: csharp">[UseReporter(typeof(DiffReporter))]
public class ElmahMvcTests
{
 private const string ElmahMvcAppUrl = &quot;http://localhost:49800/elmah&quot;;

 [Test]
 public void lock_elmah_mvc_pages()
 {
  // do
  var content = new StringBuilder();            
  var pages = new[] 
      {
       ElmahMvcAppUrl,
       ElmahMvcAppUrl + &quot;/&quot;,
       ElmahMvcAppUrl + &quot;/stylesheet&quot;,
       ElmahMvcAppUrl + &quot;/rss&quot;,
       ElmahMvcAppUrl + &quot;/digestrss&quot;,
       ElmahMvcAppUrl + &quot;/detail?id=5dd2a560-c6fd-4847-a6cc-e3e253db5764&quot;,
       ElmahMvcAppUrl + &quot;/json?id=5dd2a560-c6fd-4847-a6cc-e3e253db5764&quot;,
       ElmahMvcAppUrl + &quot;/xml?id=5dd2a560-c6fd-4847-a6cc-e3e253db5764&quot;
      };

  foreach (var page in pages)
  {
   content.Append(GetContent(page));
  }

  // verify
  ApprovalTests.Approvals.Verify(content.ToString());
 }
</pre><p>The <code>GetContent()</code> is responsible for getting page content. It could be as simple as <code>ApprovalTests.Asp.AspApprovals.GetUrlContents(url)</code>, but you might get in the trap, as I did so.<br />
</p><h2>Dealing dynamic data</h2><p>The trap is called 'Dynamic Data'. Dynamic data is every dynamic part of you output. In my case, the dynamic part was a server time generated by ELMAH and putting into page footer. Of cause, even if I run the test and approve the results, on a next test run I still have red test, since I have differences in a seconds of timestamps in footer. It's annoying, but nothing  you can do about it.<br />
</p><p>My solution was simple. Since I actually don't care about those timestamps at all, I can simple cut it away from output. The rest of the document, including structure and content would remain the same, so testing quality will not be lower. <br />
</p><p>So, the <code>GetContent()</code> method will look as follows,<br />
</p><pre class="brush: csharp">private string GetContent(string url)
{
 return RemoveFooter(ApprovalTests.Asp.AspApprovals.GetUrlContents(url));
}

private string RemoveFooter(string content)
{
 var pattern = &quot;&lt;p id=\&quot;Footer\&quot;&gt;(.*)&lt;/p&gt;&quot;;
 return new Regex(pattern).Replace(content, string.Empty);
}
</pre><h2>Approving the results</h2><p>After I had stable test output, I safely approved that test. Approving in terms of ApprovalTest framework, is simple copy of Accepted file into Approved file.<br />
</p><p>Now the system got into 'Locked' state and I'm safe to do the changes. This is something as Llewellyn mentioned 100% test coverage with one test. Indeed, having only one test and spent 10 minutes to create it I covered huge piece of functionality.<br />
</p><h2>Keep that safe</h2><p>After I applied all my changes, I re-run approval test to see how it works. I was happy to see, that I'm still generating the same output as it was before. It means, the system still functions as it's expected. All routes works, generated content does not have differences inside. Cool!<br />
</p><p>As I <a href="http://www.beletsky.net/2011/12/approval-tests-locking-down-legacy-code.html">said</a> earlier, you don't need to keep the test for all time. In my case, as I completed my refactoring and saw that code still works (and of cause, manually tested the application), it's OK just to delete approval test. No longer needed.<br />
</p><p><a href="http://approvaltests.sourceforge.net/">Approval.Tests</a> are really shines for a scenarios like that. <br />
</p></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Approval Tests: Locking down an output]]></title>
    <link href="http://alexanderbeletsky.github.io/2012/01/approval-tests-locking-down-output.html"/>
    <updated>2012-01-06T17:52:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2012/01/approval-tests-locking-down-output</id>
    <content type="html"><![CDATA[<div class='post'>
<p>        We have <a href="http://www.beletsky.net/2011/12/approval-tests-locking-down-legacy-code.html">seen</a> how Approval Tests are useful for locking down some legacy code. You might say, that on practice we are having much more bigger problem, like some code that executes queries against the database. We need somehow to be able to work with that code, without worries of brake it down. Approvals could help here. <br />
    </p>    <h2>The case</h2>    <p>        Again I just imagine some legacy code that works with DB, it might look something like that:<br />
    </p>    <pre class="brush: csharp">public class ClassThatOutputsSomething
{
 private static Connection _connection;

 public void MethodThatProduceSomeResults(string parameterOne, int parameterTwo)
 {
  if (!IsConnectionOpened())
  {
   OpenConnection();
  }

  var connection = GetConnection();

  var value = HugeAndScarryLegacyCode.TheUgliesMethodYouMightEverSeen(parameterOne, parameterTwo, 'c');

  var query = string.Format(&quot;INSERT INTO TableName (SomeColumn) VALUES ({0})&quot;, value);
  connection.ExecuteQuery(query);
 }

    // ...
    </pre>    <p>        The <code>MethodThatProduceSomeResults</code> takes some arguments, call another method to get value and then store value to database. It will be problematic to tests what exactly is happening there. We might consider approach to check the difference in <code>TableName</code> before code execution and after, but we will go smarter and easier way. <br />
    </p>    <p>        Let's prepare the test for that code.<br />
    </p>    <h2>Tests</h2>    <p>        The great thing with Approvals is the tests are really elegant. Just 2 steps - DO and VERIFY.<br />
    </p>    <pre class="brush: csharp">[Test]
public void should_be_able_to_test()
{
 // DO
 var some = new ClassThatOutputsSomething();
 some.MethodThatProduceSomeResults('some_input', 221);

 // VERIFY
 Approvals.Approve(...);
}
    </pre>    <p>        But you can see, the problem here is that we don't have any return value of that method. Instead, it does something inside and keep that action in secret. We need some how to log all internal activities and than verify that log. <code>Approval.Utilities</code> contains exactly what we need.<br />
    </p>    <pre class="brush: csharp">[Test]
public void should_be_able_to_test()
{
 // DO
 var output = ApprovalUtilities.SimpleLogger.Logger.LogToStringBuilder();
 new ClassThatOutputsSomething().MethodThatProduceSomeResults('some_input', 221);

 // VERIFY
 Approvals.Approve(output);
}
    </pre>    <p>        I have just added logger <code>ApprovalUtilities.SimpleLogger.Logger.LogToStringBuilder</code> and do approve against it. But if I run this test I could see that output is just empty. Sure, we need to change <code>MethodThatProduceSomeResults</code> a little.<br />
    </p>    <pre class="brush: csharp">public class ClassThatOutputsSomething
{
 private static Connection _connection;

 public void MethodThatProduceSomeResults(string parameterOne, int parameterTwo)
 {
        // ...

        connection.ExecuteQuery(query);
        ApprovalUtilities.SimpleLogger.Logger.Event(query);
 }
    </pre>    <p>        So, in the place where query is being executed, we placed the logger and put exact some query inside it. Now if I run the test I will got application output, that I will approve and use those approved results after. <br />
    </p>    <p>        I'm not limited with only one place I could put logger. On practice, would more that one places to grab the results, as well as more that one argument for <code>MethodThatProduceSomeResults</code> method. By analysis of particular practical case, it is possible to place logger exactly where it's needed, plus prepare best matching inputs. Just for example: after code examination it might happen that <code>parameterOne</code> is ProductId, but <code>parameterTwo</code> is ProductPrice. In my test I could query the database to select all products and prices and call <code>MethodThatProduceSomeResults</code> in loop, to get all potential output. That approved test will give me much confidence during refactoring.<br />
    </p>    <h2>Conclusion</h2>    <p>        Locking down output is very powerful technique, you can use it for any kind of objects that are "hidden" inside legacy classes, like SQL or console outputs.  <br />
    </p>    <p>        On <a href="http://herdingcode.com/?p=329">Herding Code</a> episode <a href="https://twitter.com/#!/LlewellynFalco">Llewellyn</a> describes the case of some legacy project he worked on. There was a kind of report generator and it's code was just a big mess. He did copy of production database and put it in "Read-Only" mode. By running the report, he was able to find all places where code was accessing DB, since exception is thrown in that place. Putting in just the same log instructions as I did above, he managed to grab all SQL queries that run for that particular report. Everything were just in one file.<br />
    </p>    <p>        That's the good example of reaching 100% code coverage just with one test.<br />
    </p></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Approval Tests: Locking Down Legacy Code]]></title>
    <link href="http://alexanderbeletsky.github.io/2011/12/approval-tests-locking-down-legacy-code.html"/>
    <updated>2011-12-14T19:06:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2011/12/approval-tests-locking-down-legacy-code</id>
    <content type="html"><![CDATA[<div class='post'>
<p>Suppose, you working on project with a lot of legacy code inside. I know it makes you sick, but as brave developer you want to improve things. You met that ugliest method in your life and only one thing you want to do - refactor it. But refactoring is dangerous procedure. For safe refactoring you need to have good test coverage. But wait, it is legacy code. You simply have no tests. What to do? Approvals have answer.<br />
</p><h2>Legacy code is the code that...</h2><p>Works! Right, it is ugly, un-supportable, nothing you can easy change there. But the most wonderful feature of that code - it works for years. And first thing is to get advantage of that fact!<br />
</p><p>Here is my "just for example" legacy method.<br />
</p><pre class="brush: csharp">namespace Playground.Legacy
{
    public class HugeAndScarryLegacyCode
    {
        public static string TheUgliesMethodYouMightEverSeen(string s, int i, char c)
        {
            if (s.Length > 5)
            {
                s += "_some_suffix";
            }

            var r = new StringBuilder();
            foreach (var k in s)
            {
                if ((int)k % i == 0)
                {
                    r.Append(c);
                }
                else
                {
                    if (k == c)
                    {
                        if (r.Length <= 2)
                        {
                            r.Append('a');
                        }
                        else
                        {
                            r.Append('b');
                        }
                    }
                    if (k == '^')
                    {
                        r.Append('c');
                    }
                    else
                    {
                        r.Append(k);
                    }
                }
            }

            return r.ToString();
        }
    }
}
</pre>
<p>(it's it ugly enough?)
</p><p>It has a cycles, nested if-else case and all nice features of legacy code. We need to change it, but in the same time guarantee it would not be broken.
</p><h2>Trying first simple test</h2><p>Supposing also, I'm not much in details of how exactly this function works.. So, I'm creating the test like:
</p><pre class="brush: csharp">[Test]
public void shoudl_work_some_how()
{
    Approvals.Approve(HugeAndScarryLegacyCode.TheUgliesMethodYouMightEverSeen("someinput", 10, 'c'));
}
</pre><p>I run it and got some result to approve:
</p><a href="https://lh6.googleusercontent.com/-7-utFOmYWqw/TujWEUiQc-I/AAAAAAAAH1g/-1OCWEOAQYQ/s555/result-1.jpg">
<img src="https://lh6.googleusercontent.com/-7-utFOmYWqw/TujWEUiQc-I/AAAAAAAAH1g/-1OCWEOAQYQ/s555/result-1.jpg" alt="approvals" />
</a>
<p>I approve that, cause I know that function works. But something inside tells you - that is not enough. Try to run in under the coverage: 
</p><a href="https://lh5.googleusercontent.com/-9AS23mH6UGI/TujWMRdftFI/AAAAAAAAH1o/VDbIJW4D3OQ/s621/result-2.jpg">
<img src="https://lh5.googleusercontent.com/-9AS23mH6UGI/TujWMRdftFI/AAAAAAAAH1o/VDbIJW4D3OQ/s621/result-2.jpg" alt="approvals" />
</a>
<p>That does not make me real confident with tests only one hit and coverage 76%. We have to create better tests cases.
</p><h2>Use combinations of arguments</h2><p>Approvals include some tools to deal this case. Let's change out test and write something like,
</p><pre class="brush: csharp">[Test]
public void should_try_to_cover_it()
{
    var numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".ToCharArray();
    var strings = new[] { "", "approvals", "xpdays", "^stangeword^" };

    ApprovalTests.Combinations.Approvals.ApproveAllCombinations(
        (s, i, c) => HugeAndScarryLegacyCode.TheUgliesMethodYouMightEverSeen(s, i, c),
        strings,
        numbers,
        chars);
}
</pre><p>With only few lines of code, I've got 1560 test cases and all of them are correct!
</p><a href="https://lh3.googleusercontent.com/--P4qoqgHK-A/TujWW2-jkkI/AAAAAAAAH1w/nfOWsaKJH5Y/s575/result-3.jpg">
<img src="https://lh3.googleusercontent.com/--P4qoqgHK-A/TujWW2-jkkI/AAAAAAAAH1w/nfOWsaKJH5Y/s575/result-3.jpg" alt="approvals" />
</a>
<p>Besides, I got pretty good coverage. Ideal, I would say. Now, if even one small change would happen, some of 1560 tests will notice that. </p><a href="https://lh3.googleusercontent.com/-P7b61iiuL7I/TujWflnUWUI/AAAAAAAAH14/ERoxa0k6dfI/s620/result-4.jpg">
<img src="https://lh3.googleusercontent.com/-P7b61iiuL7I/TujWflnUWUI/AAAAAAAAH14/ERoxa0k6dfI/s620/result-4.jpg" alt="approvals" />
</a>
<h2>Locking down</h2><p>The process of controlling the legacy code in that way is called "Locking down". After the code is locked down, you have high confidence (read low risk) of breaking changes you introduce. Please note how low effort it was to create all that 1560 tests and how much value gained in that.
</p><p>Notice, that test like <code>should_try_to_cover_it</code> is not supposed to "live forever". You probably even don't need to check it in to source control. You just do your job, either refactoring or changing that functionality and use Approvals to notify you as fast as possible of something goes wrong.
</p></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Approval Tests, Alternative View on Test Automation]]></title>
    <link href="http://alexanderbeletsky.github.io/2011/12/approval-tests-alternative-view-on-test.html"/>
    <updated>2011-12-11T01:19:00+02:00</updated>
    <id>http://alexanderbeletsky.github.io/2011/12/approval-tests-alternative-view-on-test</id>
    <content type="html"><![CDATA[<div class='post'>
<p><a href="https://sourceforge.net/projects/approvaltests/">Approval Tests</a> or simply Approvals in a framework created by <a href="http://twitter.com/#!/LlewellynFalco">Llewellyn Falco</a> and <a href="http://dangilkerson.users.sourceforge.net/">Dan Gilkerson</a>, providing support for .NET, Java, PHP and Ruby. It is not yet another unit testing framework like NUnit or MbUnit etc., instead those frameworks are used to run approval tests.<br />
</p><p>Broadly speaking, software is nothing more as virtual box there we put some inputs and expect on outputs. The outputs could be produces by zillion ways. Those ways are differ by its implementation. Unit tests are too much focusing on implementation. Thats why unit tests might fail even if you have working code, or otherwise. Approvals are focusing on output.<br />
</p><h2>How it works?</h2><p>Let's take a look on a very simple case. Say, I have a class <code>ShoppingCart</code>. I can add some products inside the shopping cart, confirm my purchase. I expect that total price is calculated for me. <br />
</p><pre class="brush: csharp">[TestFixture]
[UseReporter(typeof(DiffReporter))]
public class ShoppingCartTests {

    [Test]
    public void should_calculate_the_total_price_for_shopping_cart() {
        // do
        var shoppingCart = new ShoppingCart();
        shoppingCart.Add(new Product { Id = "iPad", Price = 500 });
        shoppingCart.Add(new Product { Id = "Mouse", Price = 20 });
        shoppingCart.Confirm();

        // verify
        Approvals.Approve(shoppingCart);
    }
}
</pre><p>What happens if I run this test? If I'm running it first time it fails. No matter it works or doesn't. Framework simply don't know that yet. To understand how much correct that code is, it will actually ask you, to utilized human primary power - recognition.   <br />
</p><p>In that case it will open the TortoiseDiff application and show actual and expected outputs.<br />
</p><a href="https://lh5.googleusercontent.com/-la_QjhoPxSc/TuPoxAXVteI/AAAAAAAAH0w/MdWZ0OAcalk/s779/Diff.jpg"><br />
<img src="https://lh5.googleusercontent.com/-la_QjhoPxSc/TuPoxAXVteI/AAAAAAAAH0w/MdWZ0OAcalk/s779/Diff.jpg" /><br />
</a><br />
<p>Here, I'm able just read that: "Ok, I have 2 products in my cart..one iPod and one Mouse, iPods costs 500 smth and mouse is 20 smth.. and the total price is 520 - looks good! I approve that result!".<br />
</p><p>Technically the approving is just copying actual output file to expected. As soon as test passed, actual file output is deleted and approved file resides near test code file, so you just check it in source control.<br />
</p><p>If then the shopping cart is modified and something goes wrong. There would be a failure. In case of unit tests, that would be multiple failure of different cases and it might be not so easy to understand what's exactly wrong. For approval test, it would be one failure. And the cool thing that I have a difference that shows there exactly the deviation is. <br />
</p><a href="https://lh3.googleusercontent.com/-CTO2HOQGoDs/TuPo7nJ1U8I/AAAAAAAAH04/ycao7SUf78s/s720/Diff2.jpg"><br />
<img src="https://lh3.googleusercontent.com/-CTO2HOQGoDs/TuPo7nJ1U8I/AAAAAAAAH04/ycao7SUf78s/s720/Diff2.jpg" /><br />
</a><br />
<h2>Where it works?</h2><p>It is not only the simple objects you can approve. What's the cool thing, you can approval against the different sources: objects, enumerables, files, HTML, XML etc. On a more high level: WpfForm, WinForm, ASP.NET Page. <br />
</p><p>For instance, code for ASP.NET:<br />
</p><pre class="brush: csharp">[Test]
public void should_have_approved_layout() {
    ApprovalTests.Asp.Approvals.ApproveUrl("http://localhost:62642/customer/");
}
</pre><p>Or for WPF form<br />
</p><pre class="brush: csharp">[Test]
public void should_have_approved_layout() {
    ApprovalTests.Wpf.Approvals.Approve(new Form());
}
</pre><p>With WPF and Win forms is that it's able to serialize them into images, so the actual and expected results are actually images, so it is easy to track the differences (TortoiseDiff can do that).<br />
</p><h2>When it works?</h2><p>It works best when you deal with 2 things: UI and legacy code.<br />
</p><p>Testing of UI is always a difficult part. But what you typically need is: make sure that UI is not changed and if changed, where exactly is happening. Apporvals solves that nicely. It is only one line of code test, to test ASP.NET page for instance. <br />
</p><p>Legacy is another story: you have no tests there at all, but you have to change code to implement new feature or refactor. The interesting thing about legacy code - It works! It works for years, no matter how it written (remember, virtual box). And this is a very great advantage of that code. With approvals, with only one test you can get all possible outputs (HTML, XLM, JSON, SQL or whatever output it could be) and approve, because you know - it works! After you have such test and approved result you are really much safe with a refactoring, since now you "locked down" all existing behavior.<br />
</p><p>Approvals are not something you need to run all the time, like units or integration tests. It more like handy tool. You create approval tests, you do your job and at the end of the day it might happen - you no longer needed, so you can just throw it away.<br />
</p><h2>Want to hear more?</h2><p>Just go and listen to <a href="http://herdingcode.com/?p=329">this</a> Herding Code podcast episode, or visit project <a href="https://sourceforge.net/projects/approvaltests/">web site</a> or join me at 17 December on <a href="http://xpdays.com.ua/program/">XP Days Ukraine</a> conference in Kiev, where I'm going to have a speech dedicated to Approvals.<br />
</p></div>

]]></content>
  </entry>
  
</feed>
