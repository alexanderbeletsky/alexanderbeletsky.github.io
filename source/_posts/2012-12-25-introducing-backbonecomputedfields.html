---
layout: post
title: "Introducing Backbone.ComputedFields"
date: 2012-12-25T22:28:00+02:00
comments: false
categories:
 - JavaScript
 - Backbone.js
---

<div class='post'>
    <p>        Recently, I've been working on small project which I want to share here. It's called <a href="https://github.com/alexanderbeletsky/backbone.computedfields">Backbone.ComputedFields</a> and it's small plugin that extends Backbone.Model functionality a bit.<br />
    </p>    <p>        I needed to have a model with 'virtual' fields. Namely, fields that does not belong to model directly, but being computed based on some other fields values.<br />
    <!-- more -->
    </p>    <p>        The easiest solution would be simply introduce some model methods, say <code>model.getComputedField() / model.setComputedField()</code> and store the value inside the model object. But that turns out to be bad idea, for several reasons. First, we are breaking usual Backbone interface for getting and setting values - <code>model.get('computed') / model.set('computed', 100)</code>. Also, if model is binded to a view, we are responsible for raising events manually, in case of computed or depended field changing.<br />
    </p>    <p>        So, after few iterations <a href="https://github.com/alexanderbeletsky/backbone.computedfields">Backbone.ComputedFields</a> was born. The design goals: to be simple, to be declarative, to be friendly to model binding (read, respect the events).<br />
    </p>    <h2>Use cases</h2>    <p>        Typical use cases for <a href="https://github.com/alexanderbeletsky/backbone.computedfields">Backbone.ComputedFields</a> are: calculating the prices; concatenating several fields; encapsulating the logic of retrieving object by reference.<br />
    </p>    <p>        It's fairly important, that computed field could change. Based on it's value, dependent fields should be updated.<br />
    </p>    <h2>Examples</h2>    <p>        Let's take a look on few examples. The models here are very simplified. But, it shows the main application of <a href="https://github.com/alexanderbeletsky/backbone.computedfields">Backbone.ComputedFields</a>.<br />
    </p>    <h3>Calculating prices</h3>    <p>        The model represents the product, which contains net price and VAT rate.<br />
    </p>    <pre class="brush: js">var Produc = Backbone.Model.extend({
    initialize: function () {
        this.computedFields = new Backbone.ComputedFields(this);
    },

    computed: {
        grossPrice: {
            depends: ['netPrice', 'vatRate'],
            get: function (fields) {
                return fields.netPrice * (1 + fields.vatRate / 100);
            },
            set: function (value, fields) {
                fields.netPrice = value / (1 + fields.vatRate / 100);
            }
        }
    }
});
</pre>    <p>        So, we have <code>grossPrice</code> as computed field. That field depends on 'netPrice' and 'vatRate' and being calculated by simple formulas.<br />
    </p>    <pre class="brush: js">var product = new Product({ netPrice: 100, vatRate: 20 });
var grossPrice = product.get('grossPrice');
    </pre>    <p>        In this case, gross price would be 120.<br />
    </p>    <pre class="brush: js">product.set({grossPrice: 300});
var netPrice = product.get('netPrice');
</pre>    <p>        After gross price is update, netPrice will be recalculated and netPrice will be 250.<br />
    </p>    <h3>Concatenating fields</h3>    <p>        Let's have a model to represent the person with first name and last name.<br />
    </p>    <pre class="brush: js">var Person = Backbone.Model.extend({
    initialize: function () {
        this.computedFields = new Backbone.ComputedFields(this);
    },

    computed: {
        fullName: {
            depends: ['firstName', 'lastName'],
            get: function (fields) {
                return fields.firstName + ' ' + fields.lastName;
            }
        }
    }
});
</pre>    <p>        I'm skipping the setter cause we don't need to set full name here.<br />
    </p>    <pre class="brush: js">var person = new Person({firstName: 'Alexander', lastName: 'Beletsky'});
var fullName = person.get('fullName');
</pre>    <p>        Full name 'Alexander Beletsky' is returned here.<br />
    </p>    <h3>Referenced objects</h3>    <p>        Sometimes we have a models that only contains a reference to another model. All the time, we need to get referenced object we have to create some piece of code, which it typically copy-n-pasted thought the code base. Computed field could be a good idea to encapsulate that.<br />
    </p>    <pre class="brush: js">var Invoice = Backbone.Model.extend({
    initialize: function (attrs, options) {
        this.customers = options.customers;
        this.computedFields = new Backbone.ComputedFields(this);
    },

    computed: {
        customer: {
            depends: ['customerId'],
            get: function (fields) {
                return fields.customerId && this.customers.get(fields.customerId);
            },
            set: function(customer, fields) {
                fields.customerId = customer.get('id');
            }
        }
    }
});
</pre>    <p>        Here we have customer field, which is computed. <br />
    </p>    <pre class="brush: js">var invoice = new Invoice({}, { customers: collectionOfCustomers });
var customer = invoice.get('customer');
</pre>    <p>        So, I'm able to get customer model even if invoice is just holding the invoice Id. <br />
    </p>    <pre class="brush: js">invoice.set({customer: anotherCustomer});
var customerId = invoice.get('customerId');
    </pre>    <p>        If I'm changing the customer of invoice, the 'customerId' would be initialized with id of 'anotherCustomer'.<br />
    </p>    <h2>Conclusions</h2>    <p>        <a href="https://github.com/alexanderbeletsky/backbone.computedfields">Backbone.ComputedFields</a> is still pre-mature, but I already successfully used that in one of projects. The github page contains pretty much documentation, so you should have to problems of adopting it for personal needs.<br />
    </p></div>
