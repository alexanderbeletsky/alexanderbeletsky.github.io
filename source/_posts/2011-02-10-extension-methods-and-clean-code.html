---
layout: post
title: "Extension methods and clean code"
date: 2011-02-10T10:52:00+02:00
comments: false
categories:
 - Code Kata
 - Tips
 - Clean Code
---

<div class='post'>
<p>
<a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">Extension methods</a> is one of my favorite features of C# language. It appeared from version 3.0 and became very popular.
</p>
<p>
The main goal of Extension Methods is to provide ability of extension of any class, without creating any derived classes, modifying original type or do "whatever" hacks. It is allowed to extend any type with any functionality in a very seamless fashion. What also great about Extension Methods is they allow to beautifully emulate behavior usually called pipelining (in <a href="http://lorgonblog.wordpress.com/2008/03/30/pipelining-in-f/">F#</a> or <a href="http://www.gnu.org/software/bash/manual/html_node/Pipelines.html">Bash</a>) and implement <a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of responsibility</a> pattern.
</p>
<p>
But the most important as for me - Extension Methods help to keep my <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">code clean</a>. Clean code criteria is something I concerned a lot, nowadays.
</p>
<p>
I recently started to practice with <a href="http://en.wikipedia.org/wiki/Kata_(programming)">code katas</a>, that I found essential for any developers who cares about <a href="http://www.hanselman.com/blog/SharpenTheSawForDevelopers.aspx">keeping their saw sharp</a>. So, after several iterations I came up with extension methods implementation that I pretty happy about. I'm using Roy Osherove's <a href="http://www.osherove.com/tdd-kata-1/">StringCalculator</a> kata. It is about the implementation of simple method <code>Add</code> that:
</p>
<ul>
<li>Takes numbers separated by delimiter, as string</li>
<li>Determines if custom delimiter is set</li>
<li>Split up original string to array of number tokens</li>
<li>Validates the input (no negatives allowed) and returns the sum of numbers, ignoring numbers greater than 1000</li>
</ul>
<p>
I would like to show to you both implementation and try to evaluate them from "clean code" point of view.
</p>
<p>
Original one (this is of cause a little "unwinded" version, I had a different structure with smaller methods.. But idea still the same).
</p>
<pre class="brush: csharp;">
public int Add(string numbers)
{
    var delimiters = new[] { ",", "\n" };

    if (IsCustomDelimeterProvided(numbers))
    {
        delimiters = GetDelimitersFromNumbers(numbers);
    }

    var processed = numbers;
    if (IsCustomDelimeterProvided(numbers))
    {
        processed = processed.Substring(processed.IndexOf('\n') + 1);
    }

    if (IsContainDelimeters(processed, delimiters))
    {
        var splittedNumbers = numbers.Split(delimiters, StringSplitOptions.None);
        var validation = new NumbersValidation();

        foreach (var number in splittedNumbers)
        {
            validation.Check(number);
        }

        validation.Validate();

        return splittedNumbers.Sum(p => GetIntegerWithCondition(p, IgnoreNumbersMoreThatThousand()));
    }

    return Convert.ToInt32(processed);
}
</pre>
<p>
Do you think is this code clean? I don't think so.. Of cause, it might be not so difficult to understand it, but:
</p>
<ul>
<li>Method is just too long</li>
<li>A lot of <code>if</code> statements make it difficult to see instruction flow</li>
<li>It messes up "infrastructure" code (splits, validation) with primary functionality (sum of numbers)</li>
</ul>
<p>
Let's try to read it: <i>I got the numbers and I check if custom delimiter is set on the beginning of numbers string, if so I try to extract the custom delimiters from original string. After I pre-process the string to remove custom delimiter prefix, so do not break the rest of function. If numbers string contains the delimiters, I split it up, perform the validation by helper object (which will throw exception is something wrong). Run Sum algorithm that would: covert string to integer and ignore one if it is greater that 1000.. Otherwise, it just tries to convert to integer and return</i>.
</p>
<p>
A lot of words, a lot of ifs isn't it? Thats not good.
</p>
<p>
Now, my last implementation with using of Extension Methods:
</p>
<pre class="brush: csharp;">
public int Add(string numbers)
{
    var defaultDelimiters = new string[] { ",", "\n" };
    var delimiters = numbers.CustomDelimiters().Concat(defaultDelimiters).ToArray();

    return numbers.Replace(" ", "").Split(delimiters, StringSplitOptions.RemoveEmptyEntries)
        .RemoveSpecialSymbols().ToIntegersArray().ValidateIntegersArray().IgnoreIntegersGreatThanThousand().Sum();
}
</pre>
<p>
Do you feel the power? I definitely do!
</p>
<p>
I believe that this code is very clean. It basically does not require any comments, because it looks like "plain English" explanation of what's the functionality is all about! Anyway, let's try to read: <i>I extract custom delimiters from numbers string and concatenate them with default delimiters. I replace all space with empty symbol (note: this step is not in original requirement, but I put it to keep code robust), then I split them with delimiters ignoring empty lines. After I remove all special symbols in numbers string and convert the result to array of integers. I validate this array (no negatives) and ignore any numbers great than thousand. At the end I sum up everything and return the result</i>.
</p>
<p>
What is good about this code:
</p>
<ul>
<li>
Method is very short
</li>
<li>
All details are hidden
</li>
<li>
Control flow is very straightforward
</li>
<li>
All dependent methods has meaningful names
</li>
<li>
Method does exactly what it is suppose to do
</li>
</ul>
<h2>Conclusion</h2>
<p>
Well, don't get me wrong here. I'm not saying that now only Extension Methods is a way of solving the issues. Of cause not. But if you feel the smell of pipeline of chain of responsibility patters, extension methods are right choice. As always you should consider to do not "overplay" with some particular feature of language/framework.
</p>
<p>
You can use links I gave above to read about technical details in MSDN. Check out full <a href="https://github.com/alexbeletsky/code.katas/blob/879a5765f4b8b408cc9f7b67ebdf767032433bd0/csharp/StringCalculator/StringCalculator.cs">implementation</a> and <a href="https://github.com/alexbeletsky/code.katas/blob/6fbb9907b334a364d43a868349de08971d147b10/csharp/StringCalculator/Tests/StringCalculatorTests.cs">tests</a> as my example of usage.
</p></div>
