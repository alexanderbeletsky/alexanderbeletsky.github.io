---
layout: post
title: "Using ASP.NET MVC Validation Mechanism without ASP.NET MVC"
date: 2012-01-10T21:30:00+02:00
comments: false
categories:
 - Tips
 - asp.net
---

<div class='post'>
<p>I get used to <code>DataAnnotations</code> for model validation very quickly. Indeed, it is great approach. You attribute you model with corresponding attributes, rest is done by framework. It is only <code>ModelState.IsValid</code>, all you have to do before starting working with model.<br />
</p><p>During implementation of some feature for <a href="https://github.com/alexbeletsky/candidate">candidate</a> I thought to myself, that I need need exactly same validation for my model class, but out of MVC framework. Namely, for some model class, like <a href="https://github.com/alexbeletsky/candidate/blob/master/Candidate.Core/Configurations/Parts/Github.cs">Github.cs</a> I just want to know, is it "configured" or not. And configured == valid in my context. Instead of writing custom code with checking all required properties to have some values I wished to do the same as ASP.NET MVC does, through DataAnnotations. It turned out to be possible and really easy.<br />
</p><h2>Basic start</h2><p>Assume you have such model:<br />
</p><pre class="brush: csharp">public class SimpleModel
{
 [Required]
 public string SomeProperty { get; set; }

 [Range(0,50)]
 public int SomeAnotherProperty { get; set; }
}
    </pre><p>If your goal is just to get answer "yes or no", you can create such function:<br />
</p><pre class="brush: csharp">public bool ValidateSimpleModel(SimpleModel validate)
{
 return Validator.TryValidateObject(validate, new ValidationContext(validate, null, null), null);
}
    </pre><p><a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validator.aspx">Validator</a> is a static class in DataAnnotations namespace. It takes target object, validation context and validation results collection. But due, to it just "tries" to perform validation, most of all parameters could be null.<br />
</p><h2>Use validation results</h2><p>If you need more specific information, like which field is exactly invalid you need to have <code>ICollection&lt;ValidationResult&gt;</code><br />
</p><pre class="brush: csharp">public ICollection&lt;ValidationResult&gt; ValidateSimpleModel(SimpleModel validate)
{
 var validationResults = new List&lt;ValidationResult&gt;();
 Validator.TryValidateObject(validate, new ValidationContext(validate, null, null), validationResults);

 return validationResults;
}
    </pre><p>In case of invalid object it would return non-empy collection of <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationresult.aspx">ValidationResult</a>, that would contain all relevant information.<br />
</p><h2>Wrapping up to extension method</h2><p>Finally, you can create simple extension extension method and apply DataAnnotations validation to any kind of object:<br />
</p><pre class="brush: csharp">public static class ValidatorExtensions
{
    public static bool TryValidateObject(this object validate)
    {
        return Validator.TryValidateObject(validate, new ValidationContext(validate, null, null), null);
    }
}
    </pre><p>So, the model could just have IsValid() method, like:<br />
</p><pre class="brush: csharp">public bool IsValid()
{
 return this.TryValidateObject();
}
    </pre><p>It works great for such simple task I need to accomplish.<br />
</p></div>
